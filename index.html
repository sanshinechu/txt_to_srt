<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SRT 字幕轉換器</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .file-drop-zone {
            border: 2px dashed #cbd5e1;
            transition: all 0.3s ease;
        }
        .file-drop-zone.dragover {
            border-color: #3b82f6;
            background-color: #eff6ff;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-blue-50 to-indigo-100 min-h-screen">
    <div class="container mx-auto px-4 py-8 max-w-4xl">
        <!-- 標題 -->
        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-800 mb-2">SRT 字幕轉換器</h1>
            <p class="text-gray-600">將文字檔轉換成 YouTube 標準 SRT 字幕格式</p>
        </div>

        <!-- 上傳區域 -->
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <h2 class="text-xl font-semibold text-gray-800 mb-4">上傳文字檔</h2>
            
            <div id="dropZone" class="file-drop-zone rounded-lg p-8 text-center cursor-pointer">
                <div class="mb-4">
                    <svg class="mx-auto h-12 w-12 text-gray-400" stroke="currentColor" fill="none" viewBox="0 0 48 48">
                        <path d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8m-12 4h.02" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                    </svg>
                </div>
                <p class="text-lg text-gray-600 mb-2">拖放文字檔到這裡，或點擊選擇檔案</p>
                <p class="text-sm text-gray-500">支援 .txt 格式</p>
                <input type="file" id="fileInput" accept=".txt" class="hidden">
            </div>

            <div id="fileInfo" class="mt-4 hidden">
                <div class="bg-blue-50 border border-blue-200 rounded-lg p-3">
                    <p class="text-blue-800 font-medium" id="fileName"></p>
                    <p class="text-blue-600 text-sm" id="fileSize"></p>
                </div>
            </div>
        </div>

        <!-- 格式說明 -->
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <h3 class="text-lg font-semibold text-gray-800 mb-3">支援的輸入格式</h3>
            <div class="bg-gray-50 rounded-lg p-4 font-mono text-sm">
                <p class="text-gray-700 mb-2">範例格式：</p>
                <p class="text-blue-600">[00:00:00.000 --> 00:00:05.000] 這是第一段字幕</p>
                <p class="text-blue-600">[00:00:05.500 --> 00:00:10.200]</p>
                <p class="text-blue-600">這是第二段字幕</p>
            </div>
        </div>

        <!-- 轉換按鈕 -->
        <div class="text-center mb-6">
            <button id="convertBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-8 rounded-lg shadow-lg transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                開始轉換
            </button>
        </div>

        <!-- 結果區域 -->
        <div id="resultSection" class="bg-white rounded-lg shadow-lg p-6 hidden">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-semibold text-gray-800">轉換結果</h3>
                <button id="downloadBtn" class="bg-green-600 hover:bg-green-700 text-white font-medium py-2 px-4 rounded-lg transition duration-200">
                    下載 SRT 檔案
                </button>
            </div>
            
            <div class="bg-gray-50 rounded-lg p-4 max-h-96 overflow-y-auto">
                <pre id="srtOutput" class="text-sm text-gray-700 whitespace-pre-wrap font-mono"></pre>
            </div>
            
            <div class="mt-4 text-sm text-gray-600">
                <p id="conversionStats"></p>
            </div>
        </div>

        <!-- 錯誤訊息 -->
        <div id="errorSection" class="bg-red-50 border border-red-200 rounded-lg p-4 hidden">
            <div class="flex items-center">
                <svg class="h-5 w-5 text-red-400 mr-2" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"></path>
                </svg>
                <p class="text-red-800 font-medium" id="errorMessage"></p>
            </div>
        </div>
    </div>

    <script>
        let selectedFile = null;
        let convertedSRT = '';

        // DOM 元素
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const fileInfo = document.getElementById('fileInfo');
        const fileName = document.getElementById('fileName');
        const fileSize = document.getElementById('fileSize');
        const convertBtn = document.getElementById('convertBtn');
        const resultSection = document.getElementById('resultSection');
        const srtOutput = document.getElementById('srtOutput');
        const downloadBtn = document.getElementById('downloadBtn');
        const errorSection = document.getElementById('errorSection');
        const errorMessage = document.getElementById('errorMessage');
        const conversionStats = document.getElementById('conversionStats');

        // 檔案拖放處理
        dropZone.addEventListener('click', () => fileInput.click());
        dropZone.addEventListener('dragover', handleDragOver);
        dropZone.addEventListener('dragleave', handleDragLeave);
        dropZone.addEventListener('drop', handleDrop);
        fileInput.addEventListener('change', handleFileSelect);

        function handleDragOver(e) {
            e.preventDefault();
            dropZone.classList.add('dragover');
        }

        function handleDragLeave(e) {
            e.preventDefault();
            dropZone.classList.remove('dragover');
        }

        function handleDrop(e) {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        }

        function handleFileSelect(e) {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        }

        function handleFile(file) {
            if (!file.name.toLowerCase().endsWith('.txt')) {
                showError('請選擇 .txt 格式的文字檔案');
                return;
            }

            selectedFile = file;
            fileName.textContent = file.name;
            fileSize.textContent = `檔案大小: ${(file.size / 1024).toFixed(1)} KB`;
            fileInfo.classList.remove('hidden');
            convertBtn.disabled = false;
            hideError();
            hideResult();
        }

        // 轉換處理
        convertBtn.addEventListener('click', convertToSRT);

        function convertToSRT() {
            if (!selectedFile) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    let content = e.target.result;
                    
                    // 移除 BOM
                    if (content.charCodeAt(0) === 0xFEFF) {
                        content = content.slice(1);
                    }

                    const srtContent = processTextToSRT(content);
                    displayResult(srtContent);
                } catch (error) {
                    showError('轉換過程中發生錯誤: ' + error.message);
                }
            };
            reader.readAsText(selectedFile, 'utf-8');
        }

        function processTextToSRT(content) {
            const lines = content.split('\n').map(line => line.trim()).filter(line => line);
            const srtEntries = [];
            let entryNumber = 1;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                // 尋找時間戳格式 [hh:mm:ss.mmm --> hh:mm:ss.mmm]
                const timeMatch = line.match(/\[(\d{2}:\d{2}:\d{2}\.\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2}\.\d{3})\]/);
                
                if (timeMatch) {
                    const startTime = convertTimeFormat(timeMatch[1]);
                    const endTime = convertTimeFormat(timeMatch[2]);
                    
                    // 檢查時間戳後是否有字幕文字
                    let subtitleText = line.replace(timeMatch[0], '').trim();
                    
                    // 如果同一行沒有字幕文字，檢查下一行
                    if (!subtitleText && i + 1 < lines.length) {
                        const nextLine = lines[i + 1];
                        // 確保下一行不是時間戳
                        if (!nextLine.match(/\[\d{2}:\d{2}:\d{2}\.\d{3}\s*-->\s*\d{2}:\d{2}:\d{2}\.\d{3}\]/)) {
                            subtitleText = nextLine;
                            i++; // 跳過下一行
                        }
                    }
                    
                    if (subtitleText) {
                        srtEntries.push({
                            number: entryNumber++,
                            startTime: startTime,
                            endTime: endTime,
                            text: subtitleText
                        });
                    }
                }
            }

            // 生成 SRT 格式
            return srtEntries.map(entry => 
                `${entry.number}\n${entry.startTime} --> ${entry.endTime}\n${entry.text}\n`
            ).join('\n');
        }

        function convertTimeFormat(timeStr) {
            // 將 hh:mm:ss.mmm 轉換為 hh:mm:ss,000
            const parts = timeStr.split('.');
            return parts[0] + ',000';
        }

        function displayResult(srtContent) {
            convertedSRT = srtContent;
            srtOutput.textContent = srtContent;
            
            const entryCount = (srtContent.match(/^\d+$/gm) || []).length;
            conversionStats.textContent = `成功轉換 ${entryCount} 個字幕段落`;
            
            resultSection.classList.remove('hidden');
            hideError();
        }

        // 下載處理
        downloadBtn.addEventListener('click', downloadSRT);

        function downloadSRT() {
            if (!convertedSRT) return;

            const blob = new Blob([convertedSRT], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = selectedFile.name.replace('.txt', '.srt');
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorSection.classList.remove('hidden');
        }

        function hideError() {
            errorSection.classList.add('hidden');
        }

        function hideResult() {
            resultSection.classList.add('hidden');
        }
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'981dd8b0f4b34a94',t:'MTc1ODMzNDg1Ni4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
